from Crypto.PublicKey import RSA
from RSAExploits.util import modInv
import binascii # for testing
import fractions 
import random

class rsaData:
	def __init__(self, rsaobj, txt=None):
		self.rsaobj = rsaobj
		self.txt= txt
	
	def encrypt(self):
		if self.getM() != None:
			self.setC(self.rsaobj.encrypt(long(self.getM())), 1L)	
			return True
		else:
			return False
	def decrypt(self):
		if self.getC() != None and self.rsaobj.has_private():
			self.setM(self.rsaobj.decrypt(self.getC()))	
			return True
		else:
			return False

	def getE(self):
		if hasattr(self.rsaobj, "e"):
			return self.rsaobj.e
		else:
			return None

	def setE(self, e):
		self.rsaobj = rsaObj(self.getN(), e, self.getD(), self.getP(), self.getQ())

	def getP(self):
		if hasattr(self.rsaobj, "p"):
			return self.rsaobj.p
		else:
			return None
    
	def setP(self, p):
		self.rsaobj = rsaObj(self.getN(), self.getE(), self.getD(), p, self.getQ())

	def getQ(self):
		if hasattr(self.rsaobj, "q"):
			return self.rsaobj.q
		else:
			return None
    
	def setQ(self, q):
		self.rsaobj = rsaObj(self.getN(), self.getE(), self.getD(), self.getP(), q)

	def getN(self):
		if hasattr(self.rsaobj, "n"):
			return self.rsaobj.n
		else:
			return None
    
	def setN(self, n):
		self.rsaobj = rsaObj(n, self.getE(), self.getD(), self.getP(), self.getQ())
    
	def getD(self):
		if hasattr(self.rsaobj, "d"):
			return self.rsaobj.d
		else:
			return None

	def setD(self, d):
		self.rsaobj = rsaObj(self.getN(), self.getE(), d, self.getP(), self.getQ())

	def getC(self):
		return self.txt.c
    
	def setC(self, c):
		self.txt = txt(c, idnum = self.getID(), m = self.getM())

	def getM(self):
		return self.txt.m
    
	def setM(self, m):
		self.txt.m = m
		self.txt = txt(self.getC(), idnum = self.getID(), m=m)

	def getID(self):
		return self.txt.idnum
    
	def setiD(self, idnum):
		self.txt.idnum = idnum
		self.txt = txt(self.getC(), idnum = idnum, m=self.getM())


def rsaObj(N,e,d=None,p=None,q=None):	
	N = long(int(N));e = long(int(e));
	if d != None:
		d = long(d)
	if p != None:
		p = long(p)
	if q != None:
		q = long(q) 
	if N != None and e != None and d == None and p == None and q == None:
		key = RSA.construct((N, e))
	elif N != None and e != None and d != None and p == None and q == None:
		d = long(int(d)); 
		p, q = RecoverPrimeFactors(N, e, d)		
		key = RSA.construct((N, e, d, long(p), long(q)))
	elif N != None and e != None and d != None and p != None and q == None:				
		d = long(int(d)); p = long(int(p));
		key = RSA.construct((N, e, d, p, N//p))	
	elif N != None and e != None and d != None and p != None and q != None:
		d = long(int(d)); p = long(int(p)); q = long(int(q));
		key = RSA.construct((N, e, d, p, q))
	return key	

class txt:
    def __init__(self,c,m=None,idnum=None,):
        self.c = c
        self.idnum = idnum
        self.m = m

 
def failFunction():
	print("Prime factors not found")
 
def outputPrimes(a, n):
	p = fractions.gcd(a, n)
	q = int(n / p)
	if p > q:
		p, q = q, p
	return p,q
 
 
def RecoverPrimeFactors(n, e, d):
	"""The following algorithm recovers the prime factor
		s of a modulus, given the public and private
		exponents.
		Function call: RecoverPrimeFactors(n, e, d)
		Input: 	n: modulus
				e: public exponent
				d: private exponent
		Output: (p, q): prime factors of modulus"""
 
	k = d * e - 1
	if k % 2 == 1:
		failFunction()
		return 0, 0
	else:
		t = 0
		r = k
		while(r % 2 == 0):
			r = int(r / 2)
			t += 1
		for i in range(1, 101):
			g = random.randint(0, n) # random g in [0, n-1]
			y = pow(g, r, n)
			if y == 1 or y == n - 1:
				continue
			else:
				for j in range(1, t): # j \in [1, t-1]
					x = pow(y, 2, n)
					if x == 1:
						p, q = outputPrimes(y - 1, n)
						return p, q
					elif x == n - 1:
						continue
					y = x
					x = pow(y, 2, n)
					if  x == 1:
						p, q = outputPrimes(y - 1, n)
						return p, q


'''
#Test
key = RSA.generate(1024)

k = rsaObj(key.n,key.e,key.d,key.p)
s = "abcd"
i = int(s.encode("hex"),16)

td = txt(None,i)
d = rsaData(k,td)
c = d.encrypt()
print c
p = d.decrypt()
 
print p
print binascii.unhexlify(hex(p)[2:-1])
print d.txt.c
print d.txt.m
 
print k.p
print key.n == k.p*k.q
'''
