""" The class defintion for RSA_Data """
	
from Crypto.PublicKey import RSA
import fractions 
import random

class RSA_Data:
	""" Conttains all RSA information used by currently implemented exploits

		RSA_Data is built on top of two other classes. The first is the RSAObj
		taken from the pycrypto library. This class stores the RSA modulus n,
		public exponent e, private exponent d, and prime factors p and q. We
		currently leverage the decrypt method from RSAObj. The second class is
		Text_Data which currently holds the ciphertext/plaintext
		information.

		Unfortunately the underlying implementation of RSA_Data is not
		completely hidden from the user given the way the __init__ function
		receives parameters. However, from a user's perspective, RSA_Data
		should be a container that has the following fields (along with an
		encrypt and decrypt function):

		n: RSA modulus
		e: Public exponent
		d: Private exponent
		p: First prime factor
		q: Second prime factor
		c: Ciphertext
		m: Plaintext
		id_num: Used to specify which ciphertexts are generated from the
				same plaintext
	"""

	def __init__(self, rsa_tup, txt_tup):
		""" Initialize the 2 classes using the provided parameters """
		self.rsaobj = RSA_Obj(*rsa_tup)
		self.txt = Text_Data(*txt_tup)
	
	def encrypt(self):
		""" Encrypt the current plaintext and assign it to the ciphertext """
		if self.get_m() != None:
			c = self.rsaobj.encrypt(long(self.get_m()))
			self.set_c(c)	
			return True
		else:
			return False
	def decrypt(self):
		""" Encrypt the current ciphertext and assign it to the plaintext """
		if self.get_c() != None and self.rsaobj.has_private():
			m = self.rsaobj.decrypt(self.get_c())
			self.set_m(m)	
			return True
		else:
			return False

	def get_e(self):
		""" Return the public exponent """
		if hasattr(self.rsaobj, "e"):
			return self.rsaobj.e
		else:
			return None

	def set_e(self, e):
		""" Set the public exponent """
		self.rsaobj = RSA_Obj(self.get_n(), e, self.get_d(), self.get_p(), self.get_q())

	def get_p(self):
		""" Return the first prime factor """
		if hasattr(self.rsaobj, "p"):
			return self.rsaobj.p
		else:
			return None
    
	def set_p(self, p):
		""" Set the first prime factor """
		self.rsaobj = RSA_Obj(self.get_n(), self.get_e(), self.get_d(), p, self.get_q())

	def get_q(self):
		""" Return the second prime factor """
		if hasattr(self.rsaobj, "q"):
			return self.rsaobj.q
		else:
			return None
    
	def set_q(self, q):
		""" Set the second prime factor """
		self.rsaobj = RSA_Obj(self.get_n(), self.get_e(), self.get_d(), self.get_p(), q)

	def get_n(self):
		""" Return the modulus """
		if hasattr(self.rsaobj, "n"):
			return self.rsaobj.n
		else:
			return None
    
	def set_n(self, n):
		""" Set the modulus """
		self.rsaobj = RSA_Obj(n, self.get_e(), self.get_d(), self.get_p(), self.get_q())
    
	def get_d(self):
		""" Return the private exponent """
		if hasattr(self.rsaobj, "d"):
			return self.rsaobj.d
		else:
			return None

	def set_d(self, d):
		""" Set the private exponent """
		self.rsaobj = RSA_Obj(self.get_n(), self.get_e(), d, self.get_p(), self.get_q())

	def get_c(self):
		""" Return the ciphertext """
		return self.txt.c
    
	def set_c(self, c):
		""" Set the ciphertext """
		self.txt = Text_Data(c, idnum = self.get_id(), m = self.get_m())

	def get_m(self):
		""" Return the plaintext """
		return self.txt.m
    
	def set_m(self, m):
		""" Set the plaintext """
		self.txt.m = m
		self.txt = Text_Data(self.get_c(), idnum = self.get_id(), m=m)

	def get_id(self):
		""" Return the id """
		return self.txt.idnum
    
	def set_id(self, idnum):
		""" Set the id """
		self.txt.idnum = idnum
		self.txt = Text_Data(self.get_c(), idnum = idnum, m=self.get_m())


def RSA_Obj(N,e,d=None,p=None,q=None):
	""" Wrapper for the RSAObj constructor
	
		The main reason for its existance is to compute the
		prime factors if the private exponent d is being set.
		In testing, the construct method threw exceptions because
		it wasn't able to compute the prime factors. The 
		recover_prime_factors function seems work better.
	"""	
	if N != None and e != None and d == None and p == None and q == None:
		key = RSA.construct((N, e))
	elif N != None and e != None and d != None and p == None and q == None:
		p, q = recover_prime_factors(N, e, d)		
		key = RSA.construct((N, e, d, long(p), long(q)))
	elif N != None and e != None and d != None and p != None and q == None:				
		key = RSA.construct((N, e, d, p, N/p))	
	elif N != None and e != None and d != None and p != None and q != None:
		key = RSA.construct((N, e, d, p, q))
	return key	

class Text_Data:
	""" At the moment, a container for the cipher/plaintext information """
	def __init__(self,c,idnum,m=None):
		""" Standard initializer """
		self.c = c
		self.idnum = idnum
		self.m = m

 
def fail_function():
	""" Basic fail function for recover_prime_factors() """
	print("Prime factors not found")
 
def output_primes(a, n):
	""" Returns the recovered prime factors """
	p = fractions.gcd(a, n)
	q = int(n / p)
	if p > q:
		p, q = q, p
	return p,q
 
 
def recover_prime_factors(n, e, d):
	"""The following algorithm recovers the prime factor
		s of a modulus, given the public and private
		exponents.
		Function call: RecoverPrimeFactors(n, e, d)
		Input: 	n: modulus
				e: public exponent
				d: private exponent
		Output: (p, q): prime factors of modulus"""
 
	k = d * e - 1
	if k % 2 == 1:
		fail_function()
		return 0, 0
	else:
		t = 0
		r = k
		while(r % 2 == 0):
			r = int(r / 2)
			t += 1
		for i in range(1, 101):
			g = random.randint(0, n) # random g in [0, n-1]
			y = pow(g, r, n)
			if y == 1 or y == n - 1:
				continue
			else:
				for j in range(1, t): # j \in [1, t-1]
					x = pow(y, 2, n)
					if x == 1:
						p, q = output_primes(y - 1, n)
						return p, q
					elif x == n - 1:
						continue
					y = x
					x = pow(y, 2, n)
					if  x == 1:
						p, q = output_primes(y - 1, n)
						return p, q

