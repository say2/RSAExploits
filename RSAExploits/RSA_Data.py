from Crypto.PublicKey import RSA
import fractions 
import random

class RSA_Data:
	def __init__(self, rsa_tup, txt_tup):
		self.rsaobj = RSA_Obj(*rsa_tup)
		self.txt = Text_Data(*txt_tup)
	
	def encrypt(self):
		if self.get_m() != None:
			c = self.rsaobj.encrypt(long(self.get_m()))
			self.set_c(c, 1L)	
			return True
		else:
			return False
	def decrypt(self):
		if self.get_c() != None and self.rsaobj.has_private():
			m = self.rsaobj.decrypt(self.get_c())
			self.set_m(m)	
			return True
		else:
			return False

	def get_e(self):
		if hasattr(self.rsaobj, "e"):
			return self.rsaobj.e
		else:
			return None

	def set_e(self, e):
		self.rsaobj = RSA_Obj(self.get_n(), e, self.get_d(), self.get_p(), self.get_q())

	def get_p(self):
		if hasattr(self.rsaobj, "p"):
			return self.rsaobj.p
		else:
			return None
    
	def set_p(self, p):
		self.rsaobj = RSA_Obj(self.get_n(), self.get_e(), self.get_d(), p, self.get_q())

	def get_q(self):
		if hasattr(self.rsaobj, "q"):
			return self.rsaobj.q
		else:
			return None
    
	def set_q(self, q):
		self.rsaobj = RSA_Obj(self.get_n(), self.get_e(), self.get_d(), self.get_p(), q)

	def get_n(self):
		if hasattr(self.rsaobj, "n"):
			return self.rsaobj.n
		else:
			return None
    
	def set_n(self, n):
		self.rsaobj = RSA_Obj(n, self.get_e(), self.get_d(), self.get_p(), self.get_q())
    
	def get_d(self):
		if hasattr(self.rsaobj, "d"):
			return self.rsaobj.d
		else:
			return None

	def set_d(self, d):
		self.rsaobj = RSA_Obj(self.get_n(), self.get_e(), d, self.get_p(), self.get_q())

	def get_c(self):
		return self.txt.c
    
	def set_c(self, c):
		self.txt = Text_Data(c, idnum = self.get_id(), m = self.get_m())

	def get_m(self):
		return self.txt.m
    
	def set_m(self, m):
		self.txt.m = m
		self.txt = Text_Data(self.get_c(), idnum = self.get_id(), m=m)

	def get_id(self):
		return self.txt.idnum
    
	def set_id(self, idnum):
		self.txt.idnum = idnum
		self.txt = Text_Data(self.get_c(), idnum = idnum, m=self.get_m())


def RSA_Obj(N,e,d=None,p=None,q=None):	
	if N != None and e != None and d == None and p == None and q == None:
		key = RSA.construct((N, e))
	elif N != None and e != None and d != None and p == None and q == None:
		p, q = recover_prime_factors(N, e, d)		
		key = RSA.construct((N, e, d, long(p), long(q)))
	elif N != None and e != None and d != None and p != None and q == None:				
		key = RSA.construct((N, e, d, p, N/p))	
	elif N != None and e != None and d != None and p != None and q != None:
		key = RSA.construct((N, e, d, p, q))
	return key	

class Text_Data:
	def __init__(self,c,idnum,m=None):
		self.c = c
		self.idnum = idnum
		self.m = m

 
def fail_function():
	print("Prime factors not found")
 
def output_primes(a, n):
	p = fractions.gcd(a, n)
	q = int(n / p)
	if p > q:
		p, q = q, p
	return p,q
 
 
def recover_prime_factors(n, e, d):
	"""The following algorithm recovers the prime factor
		s of a modulus, given the public and private
		exponents.
		Function call: RecoverPrimeFactors(n, e, d)
		Input: 	n: modulus
				e: public exponent
				d: private exponent
		Output: (p, q): prime factors of modulus"""
 
	k = d * e - 1
	if k % 2 == 1:
		fail_function()
		return 0, 0
	else:
		t = 0
		r = k
		while(r % 2 == 0):
			r = int(r / 2)
			t += 1
		for i in range(1, 101):
			g = random.randint(0, n) # random g in [0, n-1]
			y = pow(g, r, n)
			if y == 1 or y == n - 1:
				continue
			else:
				for j in range(1, t): # j \in [1, t-1]
					x = pow(y, 2, n)
					if x == 1:
						p, q = output_primes(y - 1, n)
						return p, q
					elif x == n - 1:
						continue
					y = x
					x = pow(y, 2, n)
					if  x == 1:
						p, q = output_primes(y - 1, n)
						return p, q

