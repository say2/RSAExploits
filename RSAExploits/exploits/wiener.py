#!/usr/bin/python

import re
import math
from sympy.solvers import solve
from sympy.core.numbers import Integer
from sympy import *
from sympy import invert
from Exploit import Exploit
from RSAExploits.util import compute_private_RSA_exp

class wiener(Exploit):

	# Attempt to recover private keys for each element in rsadata_list
	# using Wiener's attack. 
	def run(self, rsadata_list):
	
		print ("Wiener: Running Attack...")
		success = False

		for rsadata in rsadata_list:
			roots = self.wiener_attack(rsadata.getN(), rsadata.getE())
				
			# If wiener's attack was successful for the current rsaData object
			if roots != None:
				rsadata.setD(compute_private_RSA_exp(rsadata.getE(), roots))
				success = True

		if success:		
			print("Wiener: Success, roots found, assigned in rsadata.")
			return True							
		else: 			
			print("Wiener: Failure, roots not found.")
			return False


	def check(self, rsadata):
		print ("Wiener: Checking Attack...")
		if self.execute(rsadata.rsaobj.n, rsadata.rsaobj.e) != None:
			return True
		else:
			return False	

	@staticmethod
	def conFraction(fraction):
	    (a,b) = fraction
	    v=[]
	    v.append(0)
	    while not a == 1:
			(x,y) = fraction
			try:
				r =  y / x
				a = y % x
			except ZeroDivisionError as details:
				print ("Exception occured:",details)
			 	print("Continuing to next RSA data...")
				return None
			b=x
			fraction = (a,b)
			v.append(r)
	    v.append(b)
	    return v

	@staticmethod
	def makeIndexedConvergent(sequence, index):
	    (a,b)=(1,sequence[index])
	    while index>0:
		index-=1
		(a,b)=(b,sequence[index]*b+a)
	    return (b,a)

	@staticmethod
	def makeConvergents(sequence):
	    r=[]
	    for i in xrange(0,len(sequence)):
		r.append(wiener.makeIndexedConvergent(sequence,i))
	    return r

	@staticmethod
	def wiener_attack(N,e):
		v = wiener.conFraction((e,N))
		if v is None:
			return None
		conv = wiener.makeConvergents(v)
 		for frac in conv:
			(k,d)=frac
			if k == 0:
				continue
			phiN=((e*d)-1)/k
			if ((pow(N-phiN+1, 2) - 4*N) <= 0 ): # (b^2 -4ac) <= 0 
				continue
				# solving equation (a**2 + b*x + c)
			x = Symbol('x', integer=True)
			roots = []
			roots = solve(x**2 -(N-phiN+1)*x + N, x, rational=False)
	 
			if len(roots) == 2:
				if type(roots[0]) is Integer and type(roots[0]) is Integer:
						     
					if(roots[0]*roots[1] == N):
						return roots
		 

