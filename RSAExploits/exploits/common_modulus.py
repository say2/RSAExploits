from Exploit import Exploit
from RSAExploits.util import eGCD
from RSAExploits.util import modInv
from RSAExploits.util import coprime

class Common_Modulus(Exploit):

	# Looks for the presence of a common modulus vulnerabilities
	# in a list of rsaData objects. If one is found, it is exploited.
	# rsaData objects that are exploited will have their plaintext
	# fields updated. 
	def run(self, rsadata):
        
		print "Common Modulus: Running Attack..."
		success = False
		
		modulus_dictionary = self.group_ciphertexts_by_moduli_and_id(rsadata)
		ids_decrypted = {}		
	
		# Iterate through each (N, idnum) tuple in the dictionary	
		for key in modulus_dictionary:

			# If the plaintext corresponding to the id has
			# already been recovered
			if key[1] in ids_decrypted:
				continue

			# Attempt to exploit the common modulus vulnerability in each
			# unique pair of rsaData objects
			for i in range(0, len(modulus_dictionary[key]) - 1):
				
				if key[1] in ids_decrypted:
					break

				for j in range(1, len(modulus_dictionary[key])):
                    
					if key[1] in ids_decrypted:
						break
				
					# If the common modulus exploit was successful
					if self.common_modulus_exploit(modulus_dictionary[key][i], modulus_dictionary[key][j]):
						success = True
					
						# Used to skip unnecessary work and update other rsaData objects
						# with the same idnum
						ids_decrypted[key[1]] = modulus_dictionary[key][i].getM()
	
		# Update plaintext in rsaData objects with decrypted IDs
		for entry in rsadata:
			if entry.getID() in ids_decrypted:
				entry.setM(ids_decrypted[entry.getID()])
			
		if success:
			print "Common Modulus: Success, at least one message decrypted"
		else:	
			print "Common Modulus: Failure, no messages decrypted"


	# Create a dictionary of ciphertexts keyed by the modulus
	# used to encrypt them, and the user provided id number
	@staticmethod
	def group_ciphertexts_by_moduli_and_id(rsadata):
        
		modulus_dictionary = {}
    
		for entry in rsadata:
		
			# Only consider entries with an ID number for this attack
			if entry.getID() == None:
				continue

			# If the (N, idnum) tuple already exists in the dictionary, just
			# append the new entry to the already existing list
			if (entry.getN(), entry.getID()) in modulus_dictionary:
				modulus_dictionary[(entry.getN(), entry.getID())].append(entry)
		
			# Otherwise, create a new list for the new tuple
			else:
				modulus_dictionary[(entry.getN(), entry.getID())] = [entry]

		return modulus_dictionary



    # Attempt to decrypt the ciphertexts in two rsaData objects
	# using the common modulus exploit. This function assumes
	# that the two ciphertexts were generated from the same
	# plaintext
	@staticmethod
	def common_modulus_exploit(rsadata1, rsadata2):

		if rsadata1.getN() != rsadata2.getN():
			return False
		if not coprime(rsadata1.getE(), rsadata2.getE()):
			return False

		N = rsadata2.getN()
		c1 = rsadata1.getC()
		c2 = rsadata2.getC()  
     
		# Because gcd(e1, e2) = 1, we know that there must exist two integers
		# X, Y such that Xe1 + Ye2 = 1. The values of X and Y can be computed
		# using the Extended Euclidean algorithm
		g,x,y = eGCD(rsadata1.getE(), rsadata2.getE())

		# If either x or y is negative, we need to compute the multiplicative
		# modular inverse of the corresponding ciphertext and negate x/y.
		# c1 ^ -a = c1* ^ a where c1* is the multiplicative modular inverse of c1.
		if x < 0:
			x = -x
			c1 = modInv(c1, N)

		if y < 0:
			y = -y
			c2 = modInv(c2, N)

		# Compute (c1^ x * c2 ^ y) mod N    
		plaintext = (pow(c1, x, N) * pow(c2, y, N)) % N
		rsadata1.setM(plaintext)
		rsadata2.setM(plaintext)
		return True
        


