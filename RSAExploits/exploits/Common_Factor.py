sage_present = True
try:
	from sage.all_cmdline import *
except ImportError:
	sage_present = False

from RSAExploits.util import compute_priv_rsa_exp
from fractions import gcd
from RSAExploits.exploits.Exploit import Exploit

# Used to hopefully limit calls to sage's Primes() function
primes_seen = []

class Common_Factor(Exploit):

	# Attempts to recover the private RSA exponent by searching for
	# common factors in the moduli of each pair of rsadata objects
	def run(self, rsadata_list):
		
		global sage_present

		if not sage_present:
			print "Common Factor: Sage required, skipping exploit"
			return 
		
		print "Common Factor: Running Attack..."
		success = False
		for i in range(0, len(rsadata_list) - 1):
			for j in range(1, len(rsadata_list)):
				if self.common_factor_exploit(rsadata_list[i], rsadata_list[j]):
					success = True

		if success:
			print "Common Factor: Success, at least one private exponent recovered"
		else:	
			print "Common Factor: Failure, no private exponents recovered"


	# Check if the moduli in the two rsadata objects share a common factor.
	# If so, this function will attempt to recover the private exponent
	# used for decryption. Returns true if at least one private exponent 
	# has been recovered. Updates the d, p, and q fields of an rsadata
	# object if the exploit is successful
	@staticmethod
	def common_factor_exploit(rsadata1, rsadata2):
		
		global primes_seen

		ret =False

		# If the two moduli have no common factors
		p = long(gcd(rsadata1.get_n(), rsadata2.get_n()))
		if p == 1:
			return ret

		# Compute a second factor for each modulus
		q1 = long(rsadata1.get_n() / p)
		q2 = long(rsadata2.get_n() / p)
		
		# If the two factors of the first modulus are both prime
		if (p in primes_seen or p in Primes()) and (q1 in primes_seen or q1 in Primes()):

			# Update primes list to hopefully save time in the future
			primes_seen.append(p)
			primes_seen.append(q1)

			# Recover d and update fields in rsadata object
			d = compute_priv_rsa_exp(rsadata1.get_e(), (p, q1))
			rsadata1.set_d(d)
			ret = True

		# If the two factors of the second modulus are both prime
		if (p in primes_seen or p in Primes()) and (q2 in primes_seen or q2 in Primes()):
			primes_seen.append(p)
			primes_seen.append(q2)
			d = compute_priv_rsa_exp(rsadata2.get_e(), (p, q2))
			rsadata2.set_d(d)
			ret = True

		return ret

