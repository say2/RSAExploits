#!/usr/bin/env python

from RSAExploits import util
from RSAExploits.exploits.Exploit import Exploit

class Hastad(Exploit):
	
	def run(self, rsadata_list):
		print ("Hastad: Running Attack...")
		success = False		
		e_id_dict = self.group_by_e_and_id(rsadata_list)
		for group in e_id_dict:
			msg = self.hastad_broadcast_exploit(e_id_dict[group])
			if msg != None:
				success = True 
				for rsadata in e_id_dict[group]:
					rsadata.set_m(msg)			    
		if success:
			print("Hastad: Success, message found.")							
		else: 			
			print("Hastad: Failure, message not found.")
		return success
			
	# Create a dictionary of ciphertexts keyed by the private exp
	# used to encrypt them, and the user provided id number
	@staticmethod
	def group_by_e_and_id(rsadata_list):
        
		e_id_dict = {}
    
		for rsadata in rsadata_list:
		
			# Only consider entries with an ID number for this attack
			if rsadata.get_id() == None:
				continue

			# If the (e, idnum) tuple already exists in the dictionary, just
			# append the new entry to the already existing list
			if (rsadata.get_e(), rsadata.get_id()) in e_id_dict:
				e_id_dict[(rsadata.get_e(), rsadata.get_id())].append(rsadata)
		
			# Otherwise, create a new list for the new tuple
			else:
				e_id_dict[(rsadata.get_e(), rsadata.get_id())] = [rsadata]

		return e_id_dict
	

	@staticmethod
	def hastad_broadcast_exploit(rsadata_list):
	
		e = rsadata_list[0].get_e()	
		if len(rsadata_list) < e:
			return None

		ns = []
		cs = []

		for rsadata in rsadata_list:
			ns.append(rsadata.get_n())
			cs.append(rsadata.get_c())

		s = util.crt(ns, cs)
		pt = util.int_nthroot(s, e)
		if pt is not None:
			return pt
		else:
			return None

		    
