
import signal
from sage.all_cmdline import *
from Crypto.Util.number import *
from RSAExploits.util import *
from Exploit import Exploit

class factoring(Exploit):
	roots = []
	rsadataset = []
	found = None
	n = None; e = None; d = None; p = None; q = None; psi = None;
	def run_ecm(self, rsadata, t = 300):
		roots = []
		
		print ("ECM Factoring: Running Attack...")
		if type (rsadata) is not list:
			self.rsadataset.append(rsadata)
		else:
			self.rsadataset = list(rsadata)

		for rdata in self.rsadataset:
			self.n = rdata.rsaobj.n
			self.e = rdata.rsaobj.e 	
			self.roots = self.long_cal(t, self.n, "ecm")
			if self.roots != None:
				self.p, self.q = self.roots
				rdata.rsaobj.p = self.p 
				rdata.rsaobj.q = self.q
				self.psi = (self.p-1)*(self.q-1)
				self.d = modInv(self.e, self.psi)
				rdata.rsaobj.d = long(int(self.d))
				rdata.setD(rdata.rsaobj.d)
				if rdata.txt.c != None:
					rdata.decrypt()
				self.found = 1
			self.n = None; self.e = None; self.d = None; self.p = None; self.q = None; self.psi = None;
		if self.found != None:		
			print("ECM Factoring: Success, roots found, assigned in rsadata.")
			return True							
		else: 			
			print("ECM Factoring: Failure, roots not found.")
			return False
	'''	
	#example:
	k = getStrongPrime(512)
	r = next_prime(2**70);
	l = k*r
	result = ecm.factor(l);
	print result
	'''

	# works for prime factors of around 130 bits
	def run_qsieve(self, rsadata, t=300):
		nothing = None
		print ("Quadratic Sieve Factoring: Running Attack...")
		if type (rsadata) is not list:
			self.rsadataset.append(rsadata)
		else:
			self.rsadataset = list(rsadata)

		for rdata in self.rsadataset:
			self.n = rdata.rsaobj.n
			self.e = rdata.rsaobj.e 	
			self.roots, nothing = self.long_cal(t, self.n, "qsieve")
			if self.roots != None:
				self.p, self.q = self.roots
				rdata.rsaobj.p = self.p 
				rdata.rsaobj.q = self.q
				self.psi = (self.p-1)*(self.q-1)
				self.d = modInv(self.e, self.psi)
				rdata.rsaobj.d = long(int(self.d))
				rdata.setD(rdata.rsaobj.d)
				if rdata.txt.c != None:
					rdata.decrypt()
				self.found = 1
			self.n = None; self.e = None; self.d = None; self.p = None; self.q = None; self.psi = None;
		if self.found != None:		
			print("Quadratic Sieve Factoring: Success, roots found, assigned in rsadata.")
			return True							
		else: 			
			print("Quadratic Sieve Factoring: Failure, roots not found.")
			return False 

	'''
	example
	sage: p = next_prime(2^128)
	sage: q = next_prime(2^130)
	sage: n = p*q
	sage: %time qsieve(n)
	#http://www.sagemath.org/doc/thematic_tutorials/explicit_methods_in_number_theory/integer_factorization.html
	'''
	
	@staticmethod
	def signal_handler(signum, frame):
		raise Exception("Timed out!")
	
	@staticmethod
	def long_cal(t,n, method):
		signal.signal(signal.SIGALRM, factoring.signal_handler)
		signal.alarm(t)   # t seconds
		if method == "ecm":
			fn = ecm.factor
		else:
			fn = qsieve
		try:
			roots = fn(n)
		except Exception, msg:
			print t, "seconds elapsed, skipping..."
		return roots
		    
