from common_rsa_functions import egcd as egcd
from common_rsa_functions import modinv as modinv
from RSAObject import RSAObject
from fractions import gcd
from sage.all_cmdline import *
from RSAExploits.rsa import *
from Exploit import Exploit

# Used to hopefully limit calls to sage's Primes() function
primes_seen = []

class Common_Factor(Exploit):

	# Attempts to recover the private RSA exponent by searching for
	# common factors in the moduli of each pair of rsadata objects
	def run(self, rsadata_list):
		print "Common Factor: Running Attack..."
		success = False
		for i in range(0, len(rsadata_list) - 1):
			for j in range(1, len(rsadata_list)):
				if self.common_factor_exploit(rsadata_list[i], rsadata_list[j]):
					success = True

		if success:
			print "Common Factor: Success, at least one private exponent recovered"
		else:	
			print "Common Factor: Failure, no private exponents recovered"


	# Check if the moduli in the two rsadata objects share a common factor.
	# If so, this function will attempt to recover the private exponent
	# used for decryption. Returns true if at least one private exponent 
	# has been recovered. Updates the d, p, and q fields of an rsadata
	# object if the exploit is successful
	@staticmethod
	def common_factor_exploit(rsadata1, rsadata2):
		
		global primes_seen

		ret =False

		# If the two moduli have no common factors
		p = long(gcd(rsadata1.getN(), rsadata2.getN()))
		if p == 1:
			return ret

		# Compute a second factor for each modulus
		q1 = long(rsadata1.getN() / p)
		q2 = long(rsadata2.getN() / p)
		
		# If the two factors of the first modulus are both prime
		if (p in primes_seen or p in Primes()) and (q1 in primes_seen or q1 in Primes()):

			# Update primes list to hopefully save time in the future
			primes_seen.append(p)
			primes_seen.append(q1)

			# Recover d and update fields in rsadata object
			totient = (p- 1) * (q1 - 1)
			rsadata1.setD(long(modinv(rsadata1.getE(), totient)))
			ret = True

		# If the two factors of the second modulus are both prime
		if (p in primes_seen or p in Primes()) and (q2 in primes_seen or q2 in Primes()):
			primes_seen.append(p)
			primes_seen.append(q2)
			totient = (p- 1) * (q2 - 1)
			rsadata2.setD(long(modinv(rsadata2.getE(), totient)))
			ret = True

		return ret

